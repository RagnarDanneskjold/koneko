; --                                                            ; {{{1
;
; File        : prelude.knk
; Maintainer  : Felix C. Stegerman <flx@obfusk.net>
; Date        : 2019-10-14
;
; Copyright   : Copyright (C) 2019  Felix C. Stegerman
; Version     : v0.0.1
; License     : LGPLv3+
;
; --                                                            ; }}}1

; -- TODO --
;
; * add more functions!
;
; --

; -- stack shuffling --

; --                                                            ; {{{1
;
; >>> , 1 2 show-stack
; 2
; 1
; >>> , swap show-stack
; 1
; 2
;
; >>> clear-stack
; >>> 42
; 42
; >>> , dup show-stack
; 42
; 42
;
; >>> clear-stack
; >>> nil
; nil
; >>> drop
; >>> drop
; *** ERROR: stack underflow
;
; >>> , 1 2 'dup dip swap show-stack
; 1
; 2
; 1
;
; >>> clear-stack
; >>> , 1 2 over show-stack
; 1
; 2
; 1
;
; ... TODO ...
;
; --                                                            ; }}}1

:swap   [ x y . 'y 'x ] def ; primitive

 :dup   [ x   . 'x 'x       ] def
:2dup   [ x y . 'x 'y 'x 'y ] def

 :drop  [ _   . ] def
:2drop  [ _ _ . ] def

 :dip   [ x f   .  f 'x     ] def
:2dip   [ x y f .  f 'x 'y  ] def

 :over  [ x y   . 'x 'y 'x        ] def ; [ 'dup dip swap ]
:2over  [ x y z . 'x 'y 'z 'x 'y  ] def

:2call  [ x f g   . 'x f 'x g       ] def ; [ dup 'f dip g ]
:3call  [ x f g h . 'x f 'x g 'x h  ] def

; ... TODO ...

; -- arithmetic --

; --                                                            ; {{{1
;
; >>> 1 2 +
; 3
; >>> 4 3 -
; 1
; >>> 6 7 *
; 42
;
; >>> 1.0 2.0 +
; 3.0
; >>> 4.0 3 -
; 1.0
; >>> 6 7.0 *
; 42.0
;
; >>> 1.0 2.0 /
; 0.5
; >>> 8 3 div
; 2
; >>> 8 3 mod
; 2
;
; --                                                            ; }}}1

:+ ( :int   :int    ) [ __int+__          ] defmulti
:+ ( :float :float  ) [ __float+__        ] defmulti
:+ ( :int   :float  ) [ 'int->float dip + ] defmulti
:+ ( :float :int    ) [  int->float     + ] defmulti

:- ( :int   :int    ) [ __int-__          ] defmulti
:- ( :float :float  ) [ __float-__        ] defmulti
:- ( :int   :float  ) [ 'int->float dip - ] defmulti
:- ( :float :int    ) [  int->float     - ] defmulti

:* ( :int   :int    ) [ __int*__          ] defmulti
:* ( :float :float  ) [ __float*__        ] defmulti
:* ( :int   :float  ) [ 'int->float dip * ] defmulti
:* ( :float :int    ) [  int->float     * ] defmulti

:/    '__float/__ def ; aliases
:div  '__div__    def
:mod  '__mod__    def

; -- sequences --

; --                                                            ; {{{1
;
; >>> () empty?
; #t
; >>> ( 1 2 ) empty?
; #f
; >>> ( :x :y :z ) len
; 3
;
; >>> ( :one :two :three ) 1 get
; :two
; >>> () 0 get
; *** ERROR: list.get: index 0 is out of range
; >>> () 0 get^
; nil
;
; >>> ( :one :two :three ) 1 member?
; #t
; >>> ( :one :two :three ) :two elem?
; #t
;
; >>> ( 4 2 1 3 ) sort
; ( 1 2 3 4 )
;
; >>> ( 1 2 3 ) ( 4 5 ) ++
; ( 1 2 3 4 5 )
; >>> "foo" "bar" ++
; "foobar"
;
; >>> ( 0 1 2 3 4 5 6 7 8 9 ) -5 [i-)
; ( 5 6 7 8 9 )
; >>> ( 0 1 2 3 4 5 6 7 8 9 ) 5 [-j)
; ( 0 1 2 3 4 )
;
; >>> "0123456789" 5 [i-)
; "56789"
; >>> "0123456789" -5 [-j)
; "01234"
; >>> "0123456789" 3 -3 [i-j)
; "3456"
;
; >>> { x: 1, y: 2 } { x: 99 } update
; { :x 99 =>, :y 2 => }
;
; --                                                            ; }}}1

:empty?   [ .empty? ] def
:len      [ .len    ] def

:get      [ swap !get     ] def
:member?  [ swap !member? ] def
:elem?    [ swap !elem?   ] def

:get^     [ 'get 'member? 2ornil ] def

:sort     [ .sort   ] def
:++       [ !append ] def

:[i-)     [ nil [i-j)       ] def
:[-j)     [ nil swap [i-j)  ] def
:[i-j)    [ x i j . 'i 'j 1 'x !slice ] def

:update ( :dict   :dict ) [ !merge ] defmulti
:update ( :record :dict ) [ over [ 'record->dict dip !merge ] dip
                            record-type apply-dict ] defmulti   ; TODO

; ... TODO ...

; -- strings & characters --

; --                                                            ; {{{1
;
; >>> "猫" ord
; 29483
; >>> 0x732b chr
; "猫"
;
; --                                                            ; }}}1

:ord    [ .ord ]  def
:chr    '__chr__  def

; -- lists --

; --                                                            ; {{{1
;
; >>> ( 1 2 3 )
; ( 1 2 3 )
; >>> dup head
; 1
; >>> drop dup tail
; ( 2 3 )
;
; >>> , drop uncons show-stack
; ( 2 3 )
; 1
; >>> cons
; ( 1 2 3 )
;
; >>> () head
; *** ERROR: list.head: empty list
; >>> () tail
; *** ERROR: list.tail: empty list
;
; >>> () head^
; nil
; >>> () tail^
; nil
;
; >>> ( 2 3 4 ) [ dup * ] map
; ( 4 9 16 )
; >>> ( 2 3 4 ) 10 '- foldl
; 1
;
; >>> , ( "Hello" "World" ) 'say each
; Hello
; World
;
; --                                                            ; }}}1

:head   [ .head ] def
:tail   [ .tail ] def

:head^  [ 'head [ empty? not ] ornil ] def
:tail^  [ 'tail [ empty? not ] ornil ] def

:uncons [ .uncons ] def
:cons   [ !cons   ] def

:map    [ f . dup empty? [ ] [ uncons 'f dip 'f map cons ] if ] def
:foldl  [ z f . dup empty? [ drop 'z ]
                [ uncons swap 'z swap f 'f foldl ] if ] def

:each   [ f . dup empty? 'drop [ uncons 'f dip 'f each ] if ] def

; ... TODO ...

; -- miscellaneous --

; --                                                            ; {{{1
;
; >>> , [ "Hi!" say ] 5 times
; Hi!
; Hi!
; Hi!
; Hi!
; Hi!
;
; --                                                            ; }}}1

 :ornil [ nil  ordef  ] def
:2ornil [ nil 2ordef  ] def

 :ordef [ f p? d .  dup p? 'f [  drop 'd ] if ] def
:2ordef [ f p? d . 2dup p? 'f [ 2drop 'd ] if ] def

:times  [ f n . 'n 0 <= [ ] [ f 'f 'n 1 - times ] if ] def

; ... TODO ...

; -- conditionals & predicates --

; --                                                            ; {{{1
;
; >>> , :temp [ dup ( [ 15 < ] [ "is cold!" ] [ 25 > ] [ "is warm!" ] :else [ "is ok!" ] ) cond [ show " " ++ ] dip ++ say ] def
; >>> 10 temp
; 10 is cold!
; >>> 20 temp
; 20 is ok!
; >>> 30 temp
; 30 is warm!
;
; >>> 1 num?
; #t
; >>> 3.14 num?
; #t
; >>> () num?
; #f
;
; --                                                            ; }}}1

 :cond  [ cons '_&cond apply call ] def
:_&cond [ x p? f & . 'p? function? [ 'x p? ] [ 'p? ] if
          [ 'f ] [ 'x '& cons '_&cond apply ] if ] def

:num?   [ 'int? 'float? 2call or ] def

; -- TODO --

; ...

; vim: set tw=70 sw=2 sts=2 et fdm=marker :
