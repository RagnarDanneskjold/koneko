; --                                                            ; {{{1
;
; File        : prelude.knk
; Maintainer  : Felix C. Stegerman <flx@obfusk.net>
; Date        : 2019-11-26
;
; Copyright   : Copyright (C) 2019  Felix C. Stegerman
; Version     : v0.0.1
; License     : LGPLv3+
;
; --                                                            ; }}}1

:__prld__ [

; -- TODO --
;
; * more functions!
; * refactor!
;
; --

; -- aliases for primitives --                                  ; {{{1

:def                '__def__                __def__

:call               '__call__                 def
:apply              '__apply__                def
:apply-dict         '__apply-dict__           def

:if                 '__if__                   def

:defmulti           '__defmulti__             def
:defrecord          '__defrecord__            def

:=>                 '__=>__                   def
:dict               '__dict__                 def

:show               '__show__                 def
:say!               '__say!__                 def
:ask!               '__ask!__                 def

:type               '__type__                 def
:callable?          '__callable?__            def
:function?          '__function?__            def

:defmodule          '__defmodule__            def

:=                  '__=__                    def
:not=               '__not=__                 def
:<                  '__<__                    def
:<=                 '__<=__                   def
:>                  '__>__                    def
:>=                 '__>=__                   def

:int->float         '__int->float__           def
:record->dict       '__record->dict__         def

:record-type        '__record-type__          def
:record-values      '__record-values__        def
:record-type-name   '__record-type-name__     def
:record-type-fields '__record-type-fields__   def

                                                                ; }}}1

; -- stack shuffling --                                         ; {{{1

; >>> , 1 2 show-stack
; 2
; 1
; >>> , swap show-stack
; 1
; 2

:swap   [ x y . 'y 'x ] def                   ; '__swap__

; >>> , 1 2 3 rot> show-stack
; 2
; 1
; 3
; >>> , <rot show-stack
; 3
; 2
; 1

:rot>   [ x y z . 'z 'x 'y  ] def             ; [ swap 'swap dip ]
:<rot   [ x y z . 'y 'z 'x  ] def             ; [ 'swap dip swap ]

; >>> , 42 dup show-stack
; 42
; 42
; >>> clear-stack
; >>> , 1 2 2dup show-stack
; 2
; 1
; 2
; 1

 :dup   [ x   . 'x 'x       ] def
:2dup   [ x y . 'x 'y 'x 'y ] def             ; [ over over ]

; >>> nil
; nil
; >>> drop
; >>> drop
; *** ERROR: stack underflow
; >>> 42 37 2drop

 :drop  [ _   . ] def
:2drop  [ _ _ . ] def                         ; [ drop drop ]

; >>> , 42 37 nip show-stack
; 37

:nip    [ _ y . 'y ] def                      ; [ 'drop dip ]

; >>> , 1 2 over show-stack
; 1
; 2
; 1
; >>> clear-stack
; >>> , 1 2 3 2over show-stack
; 2
; 1
; 3
; 2
; 1

 :over  [ x y   . 'x 'y 'x        ] def       ; [ 'dup dip swap ]
:2over  [ x y z . 'x 'y 'z 'x 'y  ] def       ; [ over2 over2 ]

; >>> , 1 2 3 over2 show-stack
; 1
; 3
; 2
; 1

:over2  [ x y z . 'x 'y 'z 'x ] def           ; [ 'over dip swap ]

; ... TODO ...

                                                                ; }}}1

; -- combinators --                                             ; {{{1

; dip: remove top value(s), call function, restore value(s)
;
; >>> , 1 2 'dup dip show-stack
; 2
; 1
; 1
; >>> clear-stack
; >>> , 1 2 3 4 '- 2dip show-stack
; 4
; 3
; -1
; >>> clear-stack
; >>> , 1 2 3 4 'neg 3dip show-stack
; 4
; 3
; 2
; -1

 :dip   [ x f   . f 'x    ] def
:2dip   [ x y f . f 'x 'y ] def               ; [ swap 'dip dip ]
:3dip   [ swap '2dip dip  ] def

; keep: copy top value(s), call function, push value(s)
;
; >>> , 2 [ dup * ] keep show-stack
; 2
; 4
; >>> clear-stack
; >>> , 2 3 '* 2keep show-stack
; 3
; 2
; 6

 :keep  [  over 'call  dip  ] def             ; [ x f . 'x f 'x ]
:2keep  [ 2over 'call 2dip  ] def             ; [ '2dup dip 2dip ]

; bi, tri: call multiple functions on one value
;
; >>> , 35 [ 2 + ] [ 7 + ] bi show-stack
; 42
; 37
; >>> clear-stack
; >>> , 2 [ 1 + ] [ 2 * ] [ 3 - ] tri show-stack
; -1
; 4
; 3

:bi     [ x f g   . 'x f 'x g       ] def     ; [ 'keep dip call ]
:tri    [ x f g h . 'x f 'x g 'x h  ] def     ; [ 'keep 2dip bi ]

; bi$, tri$: call a function on multiple values
;
; >>> 2 3 [ dup * ] bi$ +
; 13
; >>> clear-stack
; >>> , 2 3 4 [ dup * ] tri$ show-stack
; 16
; 9
; 4

:bi$    [ x y f   . 'x f 'y f       ] def     ; [ dup bi~ ]
:tri$   [ x y z f . 'x f 'y f 'z f  ] def     ; [ dup dup tri~ ]

; bi~, tri~: "pair" multiple functions and values
;
; >>> , 4 9 [ 2 + ] [ 3 div ] bi~ show-stack
; 3
; 6
; >>> clear-stack
; >>> ( 1 2 3 :x :y :z .[ '1 swap => ] tri$ tri~ )
; ( :x 1 => :y 2 => :z 3 => )

:bi~    [ x y f g     . 'x f 'y g       ] def ; [ 'dip dip call ]
:tri~   [ x y z f g h . 'x f 'y g 'z h  ] def

; bi*: "multiply" multiple functions and values
;
; >>> , 2 3 [ dup * ] [ 1 + ] bi* show-stack
; 4
; 3
; 9
; 4

:bi*    [ x y f g . 'x f 'y f 'x g 'y g ] def ; [ [ 'bi$ 2keep ] dip bi$ ]

; >>> , 1 2 '+ '- 2bi show-stack
; -1
; 3
; >>> clear-stack
; >>> , 7 2 '+ '- 'div 2tri show-stack
; 3
; 5
; 9

:2bi    [ '2keep dip call ] def
:2tri   [ '2keep 2dip 2bi ] def

; >>> , 1 2 3 4 '+ 2bi$ show-stack
; 7
; 3
; >>> clear-stack
; >>> , 1 3 2 4 '+ 2bi$' show-stack
; 7
; 3

:2bi$   [ dup 2bi~        ] def
:2bi$'  [ 'swap 2dip 2bi$ ] def

; >>> , 1 2 3 4 '+ '- 2bi~ show-stack
; -1
; 3
; >>> clear-stack
; >>> , 1 3 2 4 '+ '- 2bi~' show-stack
; -1
; 3

:2bi~   [ '2dip dip call  ] def
:2bi~'  [ 'swap 3dip 2bi~ ] def

; ... TODO ...

                                                                ; }}}1

; -- logic --                                                   ; {{{1

; >>> #t 42 37 ?
; 42

:?      [ .[ '1 ] bi$ if ] def

; >>> 1 2 = [ "oh no!" say! ] when
; >>> 1 1 = [ "good!"  say! ] when
; good!
; >>> , 42 dup 2 mod 0 = [ 2 div ] when1 show-stack
; 21
; >>> clear-stack
; >>> 1 2 2dup = '+ when2

:when   [ [ ]    if ] def
:when1  [ 'drop  if ] def
:when2  [ '2drop if ] def

; >>> 5 not
; #f
; >>> nil not
; #t
; >>> nil 5 or
; 5
; >>> nil 5 and
; nil
; >>> 2 3 or
; 2
; >>> 2 3 and
; 3

:not    [ #f #t ?     ] def
:and    [ over ?      ] def
:or     [ 'dup dip ?  ] def

                                                                ; }}}1

; -- arithmetic --                                              ; {{{1

; >>> 1 2 +
; 3
; >>> 4 3 -
; 1
; >>> 6 7 *
; 42
; >>> 1.0 2.0 +
; 3.0
; >>> 4.0 3 -
; 1.0
; >>> 6 7.0 *
; 42.0

:+ ( :int   :int    ) [ __int+__          ] defmulti
:+ ( :float :float  ) [ __float+__        ] defmulti
:+ ( :int   :float  ) [ 'int->float dip + ] defmulti
:+ ( :float :int    ) [  int->float     + ] defmulti

:- ( :int   :int    ) [ __int-__          ] defmulti
:- ( :float :float  ) [ __float-__        ] defmulti
:- ( :int   :float  ) [ 'int->float dip - ] defmulti
:- ( :float :int    ) [  int->float     - ] defmulti

:* ( :int   :int    ) [ __int*__          ] defmulti
:* ( :float :float  ) [ __float*__        ] defmulti
:* ( :int   :float  ) [ 'int->float dip * ] defmulti
:* ( :float :int    ) [  int->float     * ] defmulti

; >>> 10 neg
; -10
; >>> -10 neg
; 10
; >>> 3.14 neg
; -3.14

:neg ( :int   ) [ 0   swap - ] defmulti
:neg ( :float ) [ 0.0 swap - ] defmulti

; >>> 1.0 2.0 /
; 0.5
; >>> 8 3 div
; 2
; >>> 8 3 mod
; 2

:/    '__float/__ def ; aliases
:div  '__div__    def
:mod  '__mod__    def

; TODO: floor, ceil, round, ...
; TODO: div/mod vs quot/rem

                                                                ; }}}1

; === WORK IN PROGRESS ===

; -- sequences -- TODO --

; --                                                            ; {{{1
;
; >>> () empty?
; #t
; >>> ( 1 2 ) empty?
; #f
; >>> ( :x :y :z ) len
; 3
;
; >>> ( :one :two :three ) 1 get^
; :two
; >>> () 0 get^
; *** ERROR: list.get^: index 0 is out of range
; >>> () 0 get
; nil
;
; >>> ( :one :two :three ) 1 member?
; #t
; >>> ( :one :two :three ) :two elem?
; #t
;
; >>> ( 4 2 1 3 ) sort
; ( 1 2 3 4 )
;
; >>> ( 1 2 3 ) ( 4 5 ) ++
; ( 1 2 3 4 5 )
; >>> "foo" "bar" ++
; "foobar"
;
; >>> ( 0 1 2 3 4 5 6 7 8 9 ) -5 [i-)
; ( 5 6 7 8 9 )
; >>> ( 0 1 2 3 4 5 6 7 8 9 ) 5 [-j)
; ( 0 1 2 3 4 )
;
; >>> "0123456789" 5 [i-)
; "56789"
; >>> "0123456789" -5 [-j)
; "01234"
; >>> "0123456789" 3 -3 [i-j)
; "3456"
;
; >>> ( 1 2 3 ) reverse
; ( 3 2 1 )
;
; >>> { x: 1, y: 2 } { x: 99 } update
; { :x 99 =>, :y 2 => }
;
; --                                                            ; }}}1

:^seq     [ <rot ^seq' ] def
:^seq'    ( :_ )  [ f g x . 'x empty? 'f
                    [ 'x 'head^ 'tail^ bi g ] if ] defmulti

:head     [ 'head^ [ empty? not ] ornil ] def
:tail     [ 'tail^ [ empty? not ] ornil ] def

:empty?   ( :_ ) [ .empty?  ] defmulti
:len      ( :_ ) [ .len     ] defmulti

:get^     [ swap !get^ ] def
:get      [ 'get^ 'member? 2ornil ] def

:member?  [ swap member?' ] def
:elem?    [ swap elem?'   ] def

:member?' ( :_ ) [ !member? ] defmulti
:elem?'   ( :_ ) [ !elem?   ] defmulti

:sort     '.sort    def
:++       '!append  def

:[i-)     [ nil [i-j)       ] def
:[-j)     [ nil swap [i-j)  ] def
:[i-j)    [ x i j . 'i 'j 1 'x !slice ] def

:reverse  ( :list ) [ () [ swap cons ] foldl ] defmulti

:update   ( :dict :dict ) [ !merge ] defmulti
:update   ( :_    :_    ) [ over [ 'record->dict dip !merge ] dip
                            record-type apply-dict ] defmulti   ; TODO

; ... TODO ...

; -- strings & characters --

; --                                                            ; {{{1
;
; >>> "猫" ord
; 29483
; >>> 0x732b chr
; "猫"
;
; --                                                            ; }}}1

:ord    '.ord     def
:chr    '__chr__  def

; -- lists -- TODO --

; --                                                            ; {{{1
;
; >>> ( 1 2 3 )
; ( 1 2 3 )
; >>> dup head^
; 1
; >>> drop dup tail^
; ( 2 3 )
;
; >>> , drop uncons^ show-stack
; ( 2 3 )
; 1
; >>> cons
; ( 1 2 3 )
;
; >>> () head^
; *** ERROR: list.head^: empty list
; >>> () tail^
; *** ERROR: list.tail^: empty list
;
; >>> () head
; nil
; >>> () tail
; nil
;
; >>> ( 2 3 4 ) [ dup * ] map
; ( 4 9 16 )
; >>> ( 2 3 4 ) 10 '- foldl
; 1
;
; >>> , ( "Hello" "World" ) 'say! each
; Hello
; World
;
; --                                                            ; }}}1

:^seq'    ( :list ) [ rot> ^list ] defmulti
:head^    ( :list ) [ .head^  ] defmulti
:tail^    ( :list ) [ .tail^  ] defmulti

:uncons^  '.uncons^ def
:cons     '!cons    def

:^list    [ f g . dup empty? [ drop f ] [ uncons^ g ] if ] def
:~list    [ h . 2over list? '^list 'h if ] def

:map      [ f . [ () ] [ 'f dip 'f map cons ] ^list ] def
:foldl    [ z f . [ 'z ] [ swap 'z swap f 'f foldl ] ^seq ] def
:each     [ f . [ ] [ 'f dip 'f each ] ^seq ] def

; ... TODO ...

; -- ranges -- TODO --

; ... TODO ...

:range    ( :start :stop ) defrecord

:[m-n]    'range            def
:[m-n)    [ 1 - [m-n]     ] def
:[0-n]    [ 0 swap [m-n]  ] def
:[0-n)    [ 0 swap [m-n)  ] def
:[1-n]    [ 1 swap [m-n]  ] def
:[1-n)    [ 1 swap [m-n)  ] def

:empty?   ( :range ) [ '> ^range ] defmulti
:len      ( :range ) [ [ swap - 1 + ] ^range ] defmulti
:elem?'   ( :range ) [ 'dup dip [ '>= '<= 2bi~' and ] ^range ] defmulti

:head^    ( :range ) [ .start ] defmulti
:tail^    ( :range ) [ [ [ 1 + ] dip range ] ^range ] defmulti

; ... TODO ...

; -- miscellaneous -- TODO --

; --                                                            ; {{{1
;
; >>> , [ "Hi!" say! ] 5 times
; Hi!
; Hi!
; Hi!
; Hi!
; Hi!
;
; --                                                            ; }}}1

 :ornil [ nil  ordef  ] def
:2ornil [ nil 2ordef  ] def

 :ordef [ f p? d .  dup p? 'f [  drop 'd ] if ] def
:2ordef [ f p? d . 2dup p? 'f [ 2drop 'd ] if ] def

:times  [ [1-n] swap ![ drop .1 ] each ] def

; ... TODO ...

; -- conditionals & predicates -- TODO --

; --                                                            ; {{{1
;
; >>> clear-stack
; >>> , :temp [
; ...     dup
; ...     ( [ 15 < ]  [ "is cold!"  ]
; ...       [ 25 > ]  [ "is warm!"  ]
; ...       :else     [ "is ok!"    ]
; ...     ) cond
; ...     [ show " " ++ ] dip ++ say!
; ...   ] def
; >>> 10 temp
; 10 is cold!
; >>> 20 temp
; 20 is ok!
; >>> 30 temp
; 30 is warm!
;
; >>> 1 num?
; #t
; >>> 3.14 num?
; #t
; >>> () num?
; #f
;
; --                                                            ; }}}1

  :cond [ _cond call ] def
 :_cond [ cons '_&cond apply ] def
:_&cond [ x p? f & .  'p? function? [ 'x p? ] [ 'p? ] if
                      [ 'f ] [ 'x '& _cond ] if ] def

:num?   [ 'int? 'float? bi or ] def

; ... TODO ...

; -- TODO --

; ...

; --

] __defmodule__

; vim: set tw=70 sw=2 sts=2 et fdm=marker :
