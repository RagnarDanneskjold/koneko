; --                                                            ; {{{1
;
; File        : prelude.knk
; Maintainer  : Felix C. Stegerman <flx@obfusk.net>
; Date        : 2020-01-04
;
; Copyright   : Copyright (C) 2020  Felix C. Stegerman
; Version     : v0.0.1
; License     : LGPLv3+
;
; --                                                            ; }}}1

:__prld__ [

; -- TODO --
;
; * more functions!
; * refactor!
; * generate docs!
;
; --

; -- aliases for primitives --                                  ; {{{1

:def                '__def__                __def__

:call               '__call__                 def
:apply              '__apply__                def
:apply-dict         '__apply-dict__           def

:if                 '__if__                   def

:defmulti           '__defmulti__             def
:defrecord          '__defrecord__            def

:=>                 '__=>__                   def
:dict               '__dict__                 def

:show               '__show__                 def
:say!               '__say!__                 def
:ask!               '__ask!__                 def

:type               '__type__                 def
:callable?          '__callable?__            def
:function?          '__function?__            def

:defmodule          '__defmodule__            def
:import             '__import__               def
:import-from        '__import-from__          def

:=                  '__=__                    def
:not=               '__not=__                 def
:<                  '__<__                    def
:<=                 '__<=__                   def
:>                  '__>__                    def
:>=                 '__>=__                   def
:<=>                '__<=>__                  def

:int->float         '__int->float__           def
:record->dict       '__record->dict__         def

:record-type        '__record-type__          def
:record-values      '__record-values__        def
:record-type-name   '__record-type-name__     def
:record-type-fields '__record-type-fields__   def

:fail               '__fail__                 def

                                                                ; }}}1

; -- stack shuffling --                                         ; {{{1

; >>> , 1 2 show-stack
; 2
; 1
; >>> , swap show-stack
; 1
; 2

:swap   [ x y . 'y 'x ] def                   ; '__swap__

; >>> , 1 2 3 rot> show-stack
; 2
; 1
; 3
; >>> , <rot show-stack
; 3
; 2
; 1

:rot>   [ x y z . 'z 'x 'y  ] def             ; [ swap 'swap dip ]
:<rot   [ x y z . 'y 'z 'x  ] def             ; [ 'swap dip swap ]

; >>> , 42 dup show-stack
; 42
; 42
; >>> clear-stack
; >>> , 1 2 2dup show-stack
; 2
; 1
; 2
; 1

 :dup   [ x   . 'x 'x       ] def
:2dup   [ x y . 'x 'y 'x 'y ] def             ; [ over over ]

; >>> nil
; nil
; >>> drop
; >>> drop
; *** ERROR: stack underflow
; >>> 42 37 2drop

 :drop  [ _     . ] def
:2drop  [ _ _   . ] def                       ; [ drop drop ]
:3drop  [ _ _ _ . ] def                       ; [ 2drop drop ]

; >>> , 42 37 nip show-stack
; 37

:nip    [ _ y . 'y ] def                      ; [ 'drop dip ]

; >>> , 1 2 over show-stack
; 1
; 2
; 1
; >>> clear-stack
; >>> , 1 2 3 2over show-stack
; 2
; 1
; 3
; 2
; 1

 :over  [ x y   . 'x 'y 'x        ] def       ; [ 'dup dip swap ]
:2over  [ x y z . 'x 'y 'z 'x 'y  ] def       ; [ over2 over2 ]

; >>> , 1 2 3 over2 show-stack
; 1
; 3
; 2
; 1

:over2  [ x y z . 'x 'y 'z 'x ] def           ; [ 'over dip swap ]

                                                                ; }}}1

; -- combinators --                                             ; {{{1

; partial application & function composition
;
; >>> , 1 '+ $
; >>> 2 swap call
; 3
; >>> , [ 1 + ] [ 3 * ] @
; >>> 2 swap call
; 9
; >>> [ 3 * ] [ 1 + ] % 2 swap call
; 9

:$      '[ '1 .2       ] def                                    ; TODO
:2$     '[ '1 '2 .3    ] def
:3$     '[ '1 '2 '3 .4 ] def

:@      '[ .1 .2 ] def
:%      '[ .2 .1 ] def

; dip: remove top value(s), call function, restore value(s)
;
; >>> , 1 2 'dup dip show-stack
; 2
; 1
; 1
; >>> clear-stack
; >>> , 1 2 3 4 '- 2dip show-stack
; 4
; 3
; -1
; >>> clear-stack
; >>> , 1 2 3 4 'neg 3dip show-stack
; 4
; 3
; 2
; -1

 :dip   [ x f   . f 'x    ] def
:2dip   [ x y f . f 'x 'y ] def               ; [ swap 'dip dip ]
:3dip   [ swap '2dip dip  ] def

; keep: copy top value(s), call function, push value(s)
;
; >>> , 2 [ dup * ] keep show-stack
; 2
; 4
; >>> clear-stack
; >>> , 2 3 '* 2keep show-stack
; 3
; 2
; 6

 :keep  [  over 'call  dip  ] def             ; [ x f . 'x f 'x ]
:2keep  [ 2over 'call 2dip  ] def             ; [ '2dup dip 2dip ]

; bi, tri: call multiple functions on one value
;
; >>> , 35 [ 2 + ] [ 7 + ] bi show-stack
; 42
; 37
; >>> clear-stack
; >>> , 2 [ 1 + ] [ 2 * ] [ 3 - ] tri show-stack
; -1
; 4
; 3

:bi     [ x f g   . 'x f 'x g       ] def     ; [ 'keep dip call ]
:tri    [ x f g h . 'x f 'x g 'x h  ] def     ; [ 'keep 2dip bi ]

; bi$, tri$: call a function on multiple values
;
; >>> 2 3 [ dup * ] bi$ +
; 13
; >>> clear-stack
; >>> , 2 3 4 [ dup * ] tri$ show-stack
; 16
; 9
; 4

:bi$    [ x y f   . 'x f 'y f       ] def     ; [ dup bi~ ]
:tri$   [ x y z f . 'x f 'y f 'z f  ] def     ; [ dup dup tri~ ]

; bi~, tri~: "pair" multiple functions and values
;
; >>> , 4 9 [ 2 + ] [ 3 div ] bi~ show-stack
; 3
; 6
; >>> clear-stack
; >>> ( 1 2 3 :x :y :z '[ '1 swap => ] tri$ tri~ )
; ( :x 1 => :y 2 => :z 3 => )

:bi~    [ x y f g     . 'x f 'y g       ] def ; [ 'dip dip call ]
:tri~   [ x y z f g h . 'x f 'y g 'z h  ] def

; bi*: "multiply" multiple functions and values
;
; >>> , 2 3 [ dup * ] [ 1 + ] bi* show-stack
; 4
; 3
; 9
; 4

:bi*    [ [ 'bi$ $ 2keep ] dip bi$ ] def

; >>> , 1 2 '+ '- 2bi show-stack
; -1
; 3
; >>> clear-stack
; >>> , 7 2 '+ '- 'div 2tri show-stack
; 3
; 5
; 9

:2bi    [ '2keep dip call ] def
:2tri   [ '2keep 2dip 2bi ] def

; >>> , 1 2 3 4 '+ 2bi$ show-stack
; 7
; 3
; >>> clear-stack
; >>> , 1 3 2 4 '+ 2bi$' show-stack
; 7
; 3

:2bi$   [ dup 2bi~        ] def
:2bi$'  [ 'swap 2dip 2bi$ ] def

; >>> , 1 2 3 4 '+ '- 2bi~ show-stack
; -1
; 3
; >>> clear-stack
; >>> , 1 3 2 4 '+ '- 2bi~' show-stack
; -1
; 3

:2bi~   [ '2dip dip call  ] def
:2bi~'  [ 'swap 3dip 2bi~ ] def

                                                                ; }}}1

; -- logic & order --                                           ; {{{1

; >>> #t 42 37 ?
; 42

:?      [ '[ '1 ] bi$ if ] def

; >>> 1 2 = [ "oh no!" say! ] when
; >>> 1 1 = [ "good!"  say! ] when
; good!
; >>> , 42 dup 2 mod 0 = [ 2 div ] when1 show-stack
; 21
; >>> clear-stack
; >>> 1 2 2dup = '+ when2

:when   [ []     if ] def
:when1  [ 'drop  if ] def
:when2  [ '2drop if ] def

; predicate "branch"
;
; >>> , :collatz [
; ...     [ [ 2 div ] [ 3 * 1 + ] 'even? ~? ]
; ...     iterate [ 1 not= ] take-while ( 1 ) ++
; ...   ] def
; >>> 19 collatz ->list
; ( 19 58 29 88 44 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 )

:~?     [ 'dup % 2dip if ] def

; >>> 5 not
; #f
; >>> nil not
; #t
; >>> nil 5 or
; 5
; >>> nil 5 and
; nil
; >>> 2 3 or
; 2
; >>> 2 3 and
; 3

:not    [ #f #t ?     ] def
:and    [ over ?      ] def
:or     [ 'dup dip ?  ] def

; comparison "branch"
;
; >>> 41 'inc 'dec 41 ~[=]
; 42
; >>> 41 'inc 'dec 99 ~[<]
; 42
; >>> 43 'inc 'dec 37 ~[<=]
; 42
; >>> 41 'inc 'dec 37 ~[>]
; 42
; >>> 41 'inc 'dec 41 ~[>=]
; 42
;
; >>> 42 37 '- '* '+ ~<=>
; 79
; >>> 37 [ :< ] [ := ] [ :> ] 42 ~[<=>] nip
; :<

:~[=]   [ '=  $ ~? ] def
:~[<]   [ '<  $ ~? ] def
:~[<=]  [ '<= $ ~? ] def
:~[>]   [ '>  $ ~? ] def
:~[>=]  [ '>= $ ~? ] def

:~<=>   [ f g h . 2dup <=> [ drop g ] [ 0 < 'f 'h if ] 0 ~[=] ] def
:~[<=>] [ y . [ 'y ] 3dip [ 'drop % ] tri$ ~<=> ] def

; >>> 1 2 min
; 1
; >>> -1 -2 max
; -1

:min    [ 2dup <= 'drop 'nip if ] def
:max    [ 2dup >= 'drop 'nip if ] def

                                                                ; }}}1

; -- arithmetic --                                              ; {{{1

; >>> 1 2 +
; 3
; >>> 4 3 -
; 1
; >>> 6 7 *
; 42
; >>> 1.0 2.0 +
; 3.0
; >>> 4.0 3 -
; 1.0
; >>> 6 7.0 *
; 42.0

:+ ( :int   :int    ) [ __int+__          ] defmulti
:+ ( :float :float  ) [ __float+__        ] defmulti
:+ ( :int   :float  ) [ 'int->float dip + ] defmulti
:+ ( :float :int    ) [  int->float     + ] defmulti

:- ( :int   :int    ) [ __int-__          ] defmulti
:- ( :float :float  ) [ __float-__        ] defmulti
:- ( :int   :float  ) [ 'int->float dip - ] defmulti
:- ( :float :int    ) [  int->float     - ] defmulti

:* ( :int   :int    ) [ __int*__          ] defmulti
:* ( :float :float  ) [ __float*__        ] defmulti
:* ( :int   :float  ) [ 'int->float dip * ] defmulti
:* ( :float :int    ) [  int->float     * ] defmulti

; >>> 10 neg
; -10
; >>> -10 neg
; 10
; >>> 3.14 neg
; -3.14

:neg ( :int   ) [ 0   swap - ] defmulti
:neg ( :float ) [ 0.0 swap - ] defmulti

; >>> 1.0 2.0 /
; 0.5
; >>> 8 3 div
; 2
; >>> 8 3 mod
; 2

:/      '__float/__ def ; aliases
:div    '__div__    def
:mod    '__mod__    def

; >>> 10 3 div?
; #f
; >>> 42 7 div?
; #t
; >>> ( 2 3 4 ) 'even? filter ->list
; ( 2 4 )
; >>> ( 1 2 3 ) 'odd? filter ->list
; ( 1 3 )

:div?   [ mod 0 =   ] def
:even?  [ 2 div?    ] def
:odd?   [ even? not ] def

; >>> 41 inc
; 42
; >>> dec
; 41

:inc    [ 1 + ] def
:dec    [ 1 - ] def

; TODO:
;   * div/mod vs quot/rem
;   * abs, floor, ceil, round**, trunc, ...
;   * pi, exp, log, sqrt, sin, cos, ...
;   * ^ :math import ?!

                                                                ; }}}1

; -- strings & characters --                                    ; {{{1

; >>> "猫" ord
; 29483
; >>> 0x732b chr
; "猫"

:ord    '.ord     def
:chr    '__chr__  def

; >>> "foo" ->str
; "foo"
; >>> :foo ->str
; ":foo"
; >>> 42 ->str
; "42"

:->str  ( :str  ) [       ] defmulti
:->str  ( :_    ) [ show  ] defmulti

                                                                ; }}}1

; -- nil, num, & pair --                                        ; {{{1

; nil "branch"
;
; >>> , :f [ [ "nil!" say! ] [ type show say! ] ~nil ] def
; >>> nil f
; nil!
; >>> 42 f
; :int
; >>> ( 1 ) 'rest ~> 'first ~> [ 1 + ] ~>
; nil
; >>> ( 1 2 ) 'rest ~> 'first ~> [ 1 + ] ~>
; 3
; >>> ( 3 4 ) ( 'rest 'first [ 1 + ] ) ~~>
; 5

:~nil   [ [ 'drop % ] dip 'nil? ~? ] def
      ; [ x f g . 'x nil? 'f [ 'x g ] if ]
      ; [ <rot '[ '2 .1 ] 'nil? bi rot> if ]

:~>     [ [ nil ] swap ~nil ] def
:~~>    [ [] [ .[ .1 '2 ~~> ] ~> ] ^seq ] def

; >>> 1 num?
; #t
; >>> 3.14 num?
; #t
; >>> () num?
; #f

:num?   [ 'int? 'float? bi or ] def

; number "branch"
;
; >>> 0 [ " negative" ] [ " non-negative" ] ~neg  'show dip ++ say!
; 0 non-negative
; >>> 0 [ " zero"     ] [ " non-zero"     ] ~zero 'show dip ++ say!
; 0 zero
; >>> 0 [ " positive" ] [ " non-positive" ] ~pos  'show dip ++ say!
; 0 non-positive
;
; >>> 4 [ :neg ] [ :zero ] [ :pos ] ~int nip
; :pos

:~neg   [ 0 ~[<] ] def
:~zero  [ 0 ~[=] ] def
:~pos   [ 0 ~[>] ] def

:~int   [ 0 ~[<=>] ] def

; TODO: floats

; pair "pattern match"
;
; >>> , x: 42 'swap ^pair, show-stack
; :x
; 42

:^pair  [ [ '.key '.value bi ] dip call ] def

                                                                ; }}}1

; -- sequences, lists, & ranges --                              ; {{{1

; TODO: step, floats

; NB: inclusive; infinite if stop is nil
:Range ( :start :stop ) defrecord

:[m-n]  'Range            def
:[m-n)  [ dec    [m-n]  ] def
:[m-)   [ nil    [m-n]  ] def
:[0-n]  [ 0 swap [m-n]  ] def
:[0-n)  [ 0 swap [m-n)  ] def
:[0-)   [ 0 nil  [m-n]  ] def
:[1-n]  [ 1 swap [m-n]  ] def
:[1-n)  [ 1 swap [m-n)  ] def
:[1-)   [ 1 nil  [m-n]  ] def

; >>> 42 1list
; ( 42 )
; >>> :x :y 2list
; ( :x :y )

:1list  [ () cons     ] def
:2list  [ 1list cons  ] def

; lazy sequence
;
; >>> , [ "evaluated once" say!, ( 1 2 3 ) ] lazy-seq
; >>> dup !thunk
; evaluated once
; ( 1 2 3 )
; >>> drop !thunk
; ( 1 2 3 )

:LSeq ( :chunk :thunk ) defrecord   ; NB: chunk must be a list

:lseq     [ __thunk__  LSeq ] def
:lseq1    [ '1list dip lseq ] def
:lazy-seq [ () swap    lseq ] def

; seq returns either the sequence (when not empty) or nil
;
; >>> nil seq
; nil
; >>> "foo" seq
; ( "f" "o" "o" )
; >>> ( 1 2 3 ) seq
; ( 1 2 3 )
; >>> () seq
; nil
; >>> { x: 1, y: 2 } seq
; ( :x 1 => :y 2 => )
; >>> 10 [1-n] dup seq =
; #t
; >>> [ ( 1 2 3 ) ] lazy-seq seq
; ( 1 2 3 )

:seq    ( :nil    ) [ ] defmulti
:seq    ( :str    ) [ '->list _~seq->nil ] defmulti             ; TODO
:seq    ( :list   ) [ []      _~seq->nil ] defmulti
:seq    ( :dict   ) [ '.pairs _~seq->nil ] defmulti             ; TODO
:seq    ( :Range  ) [ []      _~seq->nil ] defmulti
:seq    ( :LSeq   ) [ dup .chunk empty? [ !thunk seq ] when ] defmulti

:_~seq->nil [ [ nil ] swap ~seq ] def

; unseq <=> 'first 'rest bi
;
; >>> , ( 1 2 ) unseq show-stack
; ( 2 )
; 1
; >>> clear-stack
; >>> , 3 10 [m-n] unseq len show-stack
; 7
; 3
; >>> clear-stack
; >>> , [ ( 1 2 ) ] lazy-seq unseq show-stack
; ( 2 )
; 1

:unseq  ( :list   ) [ [ nil nil ] [] ^list ] defmulti
:unseq  ( :Range  ) [ [ nil nil ]
                      [ [ [ dup inc ] dip Range ] ^Range ] ~seq
                    ] defmulti
:unseq  ( :LSeq   ) [ [ t .
                      [ unseq 't LSeq ] [ drop t unseq ] 'seq ~?
                    ] ^LSeq ] defmulti

; first and rest resturn the first element (or nil) and the rest of
; the sequence (or nil), respectively
;
; >>> ( 1 2 3 ) first
; 1
; >>> ( 1 2 3 ) rest
; ( 2 3 )

:first  ( :_ ) [ unseq drop ] defmulti
:rest   ( :_ ) [ unseq nip  ] defmulti

; empty? <=> seq not
;
; >>> "foo" empty?
; #f
; >>> () empty?
; #t
; >>> { x: 1 } empty?
; #f
; >>> 1 [1-n] rest empty?
; #t
; >>> ( 1 2 3 ) [ 1 + ] map empty?
; #f

:empty? ( :str    ) [ .empty? ] defmulti
:empty? ( :list   ) [ .empty? ] defmulti
:empty? ( :dict   ) [ .empty? ] defmulti
:empty? ( :Range  ) [ [ [ drop #f ] '> ~nil ] ^Range ] defmulti
:empty? ( :_      ) [ seq not ] defmulti

; >>> "foo" len
; 3
; >>> ( 1 2 ) len
; 2
; >>> { x: 1 } len
; 1
; >>> 37 42 [m-n) len
; 5
; >>> 42 [m-) len
; nil
; >>> ( 1 2 3 ) [ 2 >= ] filter len
; 2

:len    ( :str    ) [ .len        ] defmulti
:len    ( :list   ) [ .len        ] defmulti
:len    ( :dict   ) [ .len        ] defmulti
:len    ( :Range  ) [ range-len   ] defmulti
:len    ( :_      ) [ ->list len  ] defmulti                    ; TODO

:range-len [ [ [ drop nil ] [ swap - inc 0 max ] ~nil ] ^Range ] def

; append two sequences
;
; >>> "foo" "bar" ++
; "foobar"
; >>> ( 1 2 3 ) ( 4 5 ) ++
; ( 1 2 3 4 5 )

:++     ( :str  :str  ) [ !append ] defmulti
:++     ( :list :list ) [ !append ] defmulti

; >>> ( 1 2 3 ) [ ( 4 5 ) ] lazy-seq ++ ->list
; ( 1 2 3 4 5 )
; >>> [ ( 1 2 3 ) ] lazy-seq ( 4 5 ) ++ ->list
; ( 1 2 3 4 5 )

:++     ( :nil  :list ) [ nip                     ] defmulti    ; TODO
:++     ( :nil  :LSeq ) [ nip                     ] defmulti
:++     ( :list :LSeq ) [ [ '++ dip LSeq ] ^LSeq  ] defmulti
:++     ( :LSeq :list ) [ _lseq++                 ] defmulti
:++     ( :LSeq :LSeq ) [ _lseq++                 ] defmulti

:_lseq++ [ l . [ [ 'l ++ ] @ lseq ] ^LSeq ] def

; >>> "foo" ->list
; ( "f" "o" "o" )
; >>> ( 1 2 3 ) ->list
; ( 1 2 3 )
; >>> { x: 1, y: 2 } ->list
; ( :x 1 => :y 2 => )

:->list ( :str  ) [ .->list ] defmulti
:->list ( :list ) [         ] defmulti
:->list ( :dict ) [ .pairs  ] defmulti

:->list ( :_    ) [ xs . ( 'xs [] each ) ] defmulti             ; TODO
                ; [ [ () ] [ ->list cons ] ^seq ]

; list & seq "pattern match"
;
; >>> ( 1 2 3 ) [ "empty" ] [ hd tl . 'hd ] ^list  ; head or "empty"
; 1
; >>> () [ "empty" ] 'drop ^seq
; "empty"
; >>> ( 4 5 ) [ "empty" ] 'head^ ~seq
; 4

:^list  [ f g . [ drop f ] [ .uncons^ g ] '.empty? ~? ] def
:^seq   [ 'seq 2dip 'unseq % ~nil ] def
:~seq   [ [ 'drop % ] dip 'empty? ~? ] def

; >>> () 'len when-seq
; nil
; >>> ( 1 2 3 ) 'len when-seq
; 3
; >>> ( 1 2 3 ) 'drop with-seq
; 1
; >>> () 'drop with-seq
; nil

:when-seq [ [ seq dup ] dip when  ] def
:with-seq [ [ nil ] swap ^seq     ] def

; "lazy" map & filter
;
; >>> ( 1 2 3 ) [ dup * ] map ->list
; ( 1 4 9 )
; >>> ( 1 2 3 ) 'dup map ->list
; ( 1 1 2 2 3 3 )
; >>> ( 1 2 3 4 ) [ 2 mod 0 = ] filter ->list
; ( 2 4 )

:map    [ f . [ x xt . ( 'x f ) [ 'xt 'f map ] lseq ] with-seq ] def
:filter [ .[ [] 'drop '1 ~? ] map ] def

; >>> ( 1 2 ) ( 3 4 5 ) '2list zip ->list
; ( ( 1 3 ) ( 2 4 ) )
; >>> [1-) ( :x :y ) [ swap => ] zip ->list dict
; { :x 1 =>, :y 2 => }

:zip    [ f . [ drop nil ] [ y yt . [ x xt .
          ( 'x 'y f ) [ 'xt 'yt 'f zip ] lseq
        ] with-seq ] ^seq ] def

; TODO: unzip

; >>> ( 2 3 4 ) 10 '- foldl
; 1
; >>> ( 2 3 4 ) () [ [ 1 + ] dip cons ] foldr         ; "strict"
; ( 3 4 5 )
; >>> ( 2 3 4 ) () [ [ 1 + ] dip call cons ] foldr'   ; "lazy"
; ( 3 4 5 )

:foldl  [ f . swap [] [ rot> f 'f foldl      ] ^seq ] def
:foldr  [ f . swap [] [ <rot 'f foldr f      ] ^seq ] def
:foldr' [ f . swap [] [ <rot 'f 'foldr' 3$ f ] ^seq ] def
      ; [ f . swap [] [ <rot .[ '1 '2 'f foldr' ] f ] ^seq ]

; TODO: scanl, scanr
; TODO: any, all
; TODO: min, max, sum, prod

; >>> ( ( 1 2 3 ) dup [ dup * ] map ) concat ->list
; ( 1 2 3 1 4 9 )
; >>> ( 1 2 3 ) reverse                               ; "strict"
; ( 3 2 1 )

:concat   [ () [ lazy-seq ++ ] foldr' ] def
:reverse  ( :_ ) [ () [ swap cons ] foldl ] defmulti

; >>> , ( "Hello" "World" ) 'say! each
; Hello
; World
; >>> , ( 1 2 3 ) [] each show-stack
; 3
; 2
; 1
; >>> ( ( 1 2 ) 'dup each )
; ( 1 1 2 2 )

:each   [ f . [] [ 'f dip 'f each ] ^seq ] def

; >>> ( 1 2 3 ) cycle 10 take-first ->list
; ( 1 2 3 1 2 3 1 2 3 1 )
; >>> 0 'inc iterate 10 take-first 2 drop-first ->list
; ( 2 3 4 5 6 7 8 9 )
; >>> 1 [ 2 * ] iterate [ 10 < ] drop-while [ 80 < ] take-while ->list
; ( 16 32 64 )
; >>> 42 repeat 4 take-first ->list
; ( 42 42 42 42 )
; >>> :x 3 replicate ->list
; ( :x :x :x )

:cycle      [ repeat concat ] def
:iterate    [ x f . 'x [ 'x f 'f iterate ] lseq1 ] def
:repeat     [ dup 'repeat $ lseq1 ] def
:replicate  [ 'repeat dip take-first ] def

:take-first [ n . [
              'n [ dec 'take-first 2$ lseq1 ] [ 3drop nil ] ~pos
            ] with-seq ] def

:drop-first [ n . [
              'n 0 > [ rest 'n dec drop-first ] when
            ] when-seq ] def

:take-while [ p? . nil [ over p? 'lseq1 [ 2drop nil ] if ] foldr' ] def

:drop-while [ p? . [
              dup first p? [ rest 'p? drop-while ] when
            ] when-seq ] def

; TODO: split-at, split-w/, ...
; TODO: last, init

                                                                ; }}}1

; -- lists, dicts, & indexing --                                ; {{{1

; >>> ( 1 2 3 )
; ( 1 2 3 )
; >>> dup head^
; 1
; >>> drop dup tail^
; ( 2 3 )
; >>> , drop uncons^ show-stack
; ( 2 3 )
; 1
; >>> cons
; ( 1 2 3 )
; >>> () head^
; *** ERROR: list.head^: empty list
; >>> () tail^
; *** ERROR: list.tail^: empty list
; >>> () head
; nil
; >>> () tail
; nil
; >>> ( 4 2 1 3 ) sort
; ( 1 2 3 4 )

:head^    '.head^ def
:tail^    '.tail^ def

:head     [ 'head^ _~seq->nil ] def
:tail     [ 'tail^ _~seq->nil ] def

:uncons^  '.uncons^ def
:cons     '!cons    def
:sort     '.sort    def

; >>> { x: 1, y: 2 } { x: 99 } update
; { :x 99 =>, :y 2 => }

:update ( :dict :dict ) [ !merge ] defmulti
:update ( :_    :_    ) [ over [ 'record->dict dip !merge ] dip
                          record-type apply-dict ] defmulti     ; TODO

; >>> { x: 1, y: 2 } dup keys
; ( :x :y )
; >>> drop values
; ( 1 2 )

:keys   ( :dict   ) [ .keys   ] defmulti
:values ( :dict   ) [ .values ] defmulti

:keys   ( :_      ) [ record-type record-type-fields  ] defmulti
:values ( :_      ) [ record-values                   ] defmulti

; >>> "0123456789" 5 [i-)
; "56789"
; >>> "0123456789" -5 [-j)
; "01234"
; >>> "0123456789" 3 -3 [i-j)
; "3456"
; >>> ( 0 1 2 3 4 5 6 7 8 9 ) -5 [i-)
; ( 5 6 7 8 9 )
; >>> ( 0 1 2 3 4 5 6 7 8 9 ) 5 [-j)
; ( 0 1 2 3 4 )
; >>> 10 20 [m-n] 2 -2 [i-j) ->list
; ( 12 13 14 15 16 17 18 )

:[i-j)  [ x i j . 'i 'j 1 'x slice  ] def                       ; TODO
:[i-)   [ nil      [i-j)            ] def
:[-j)   [ nil swap [i-j)            ] def

:slice  ( :str    ) [ !slice      ] defmulti
:slice  ( :list   ) [ !slice      ] defmulti
:slice  ( :Range  ) [ range-slice ] defmulti

; TODO: errors, step
:range-slice  [ _ r .
                [ 0 or ] [ 'r len or ] bi~
                [ 'r swap range-relidx ] bi$
                over [ [ drop nil ] [ swap - ] ~nil ] dip
                'r range-drop range-take
              ] def
:range-relidx [ [ drop nil ] [ [ 'len dip + ] 'nip ~neg ] ~nil ] def
:range-drop   [ [ '+ dip Range ] ^Range ] def
:range-take   [ [ <rot [] [
                swap [ over + dec ] dip [] 'min ~nil
              ] ~nil Range ] ^Range ] def

; >>> ( :one :two :three ) 1 get^
; :two
; >>> () 0 get^
; *** ERROR: list.get^: index 0 is out of range
; >>> ( 1 2 3 ) 1 get
; 2
; >>> () 0 get
; nil
; >>> ( :one :two :three ) 1 has?       ; valid index of
; #t
; >>> ( :one :two :three ) :two elem?   ; element of
; #t

:get    [ 2dup has? 'get^ [ 2drop nil ] if ] def

:get^   [ swap get^'  ] def
:has?   [ swap has?'  ] def
:elem?  [ swap elem?' ] def

:get^'  ( :_ ) [ !get^  ] defmulti
:has?'  ( :_ ) [ !has?  ] defmulti
:elem?' ( :_ ) [ !elem? ] defmulti

; TODO
:elem?' ( :Range ) [ 'dup dip [ '>= '<= 2bi~' and ] ^Range ] defmulti

                                                                ; }}}1

; -- "quasi-macros" --                                          ; {{{1

; >>> { x: 1, y: 2 } [ 'y 'x + ] let
; 3

:let    [ [ '.values '.keys bi ] dip '__block-code__ [] bi __block__
          apply ] def                                           ; TODO

                                                                ; }}}1

; -- miscellaneous --                                           ; {{{1

; >>> id
; >>> []
; [ ]

:id     [     ] def
:[]     [ 'id ] def

; >>> , [ "Hi!" say! ] 5 times
; Hi!
; Hi!
; Hi!
; Hi!
; Hi!

:times  [ [1-n] swap 'drop % each ] def

; conditional expression
;
; Takes a value and a list of tests and exprs.  It evaluates each test
; one at a time: functions are predicates and are called with the
; value pushed onto the stack; the result -- or the test itself if not
; a function -- is tested for truthiness.  If the test passes, its
; corresponding expr is returned; and called if it's a block.
;
; >>> , :temp [
; ...     [ show " is " ++ ]
; ...     [ ( [ 15 < ] "cold!" [ 25 > ] "warm!" :else "ok!" ) cond ]
; ...     bi ++ say!
; ...   ] def
; >>> 10 temp
; 10 is cold!
; >>> 20 temp
; 20 is ok!
; >>> 30 temp
; 30 is warm!

  :cond [ _cond dup block? 'call when ] def                     ; TODO
 :_cond [ cons '_&cond apply ] def
:_&cond [ x p? f & .
          'x 'p? 'call 'nip 'function? ~? [ 'f ] [ 'x '& _cond ] if
        ] def

                                                                ; }}}1

; ...

; -- END --

] __defmodule__

; vim: set tw=70 sw=2 sts=2 et fdm=marker :
